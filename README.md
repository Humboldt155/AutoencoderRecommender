Использован подход, описанный в статье 
"Training Deep AutoEncoders for Collaborative Filtering"(https://arxiv.org/abs/1708.01715)

## 1. Терминология

##### 1.1 Модель Адео

Товарная категория Адео.
Обученный алгоритм, в сфере машинного обучения, принято называть Моделью.
Однако, в компании LeroyMerlin Моделью принято называть категорию товаров, утвержденную ADEO. 
Так как проект опирается на активное использование Моделей Адео, слово Модель 
будет использоваться только в значении Товарной категории.
  
##### 1.2 Автоэнкодер

Обученный алгоритм, который в сфере машинного обучения называется моделью.
Мы обучаем Автоэнкодер, и Автоэнкодер делает прогнозы.
  
##### 1.3 Проект клиента
  
То, что сейчас делает клиент. 
Ремонт дома, строительство сарая, установка окна, ремонт протекающего бачка унитаза, это 
все проект.
Проект может быть простым, или состоять из этапов. На каждом этапе клиенту необходимы 
определенные типы товаров.



## Требования
* Python 3.6
* Pytorch 0.4.0
* CUDA >= 8.0

В данном приложении исплоьзуются Deep Autoencoders для создания системы рекоммендаций для 
клиентов LeroyMerlin.
В данном файле описано, по какому принципу организован API для оболочки автоэнкодэра.
Автоэнгодэр в этом приложении создан с использованием библиотеки [PyTorch](http://pytorch.org/)
и основан на репозитории NVIDIA.

Для API мы используем библиотеки:
* [Flask](http://flask.pocoo.org/) - микрофреймворк, созданный на Python, для запуска web 
приложений
* [CherryPy](https://cherrypy.org/) - минималистичный фреймворк для создания web приложений 
на Python

## Адаптация модели для Leroy Merlin

Выбранная модель была создана в 2017 году, и показала очень высокую точность предсказания. 
Изначально модель создана и протестирована на пользовательских оценках фильмов из базы данных 
Netflix.

### Товарные категории (модель Адео) вместо конкретных товаров

Основная цель Алгоритма - угадать проект клиента, понять, на какой он стадии, и предложить 
нужные продукты.
Модель не ставит себе целью понять, какую именно, к примеру, дрель предложить клиенту.
Цель модели - угадать, что конкретному клиенту в данным момент потребоваться дрель, и 
сократить его путь к данной категории.
Ввиду этого, первым этапом артикулы заменяются на модели Адео, в которых они находятся.

Данный подход, модель Адео вместо конкретного артикула, имеет ряд преимуществ:
* Снижается зависимость от периода обучения. 
Если происходит смена коллекции, и одни дрели заменяются на другие, 
Автоэнкодер всегда работает с одной единицей - моделью Дрели.
* Значительно сокращается количество анализируемых продуктов (со 190тыс до 10тыс), 
благодаря чему в десятки раз повышается точность Автоэнкодера.
* Модель не зависит от того, что в разных городах разные гаммы товаров.
* Модель сможет легко работать с новинками, включая товары лонгтейл и маркетплейс.
* Более простая постобработка рекоммендаций - получаем номер модели, 
накладываем нужные нам фильтры (например, предлагаем только СТМ)
* Ввиду того, что модели Адео международные, есть возможность работать с одним Алгоритмом 
(как дообучать, так и пользоваться), как в России, так и в других странах, в которых базы 
данных основаны на Step.

### Проекты имеют жизненный цикл и порядок

Система рекоммендаций для DIY существенно отличается от таковой для FMCG, Фильмов, Музыки. 
Цель данной модели - улучшить изначальный алгоритм, чтобы учесть следующие факторы.

* Проект клиента - пошаговый процесс. Например, если клиент купил напольное покрытие, то,
 несмотря на то, что 



# Подготовка данных

Первый этап - конвертация данных в формат, который Автоэнкодер сможет прочитать.
Это может занять  ..... часов

Код:
%% time
%% run ./DeepRecommender/data_utils/leroy_data_convert.py

Скрипт разделяет данные на Тренировочный, Тестовый и Валидационный, 
создавая файлы с тремя колонками: CustomerID, ModelID, Probability

Ниже таблица с данными:


Взглянем на один из файлов:

Код:
%% lm_valid = os.path.join(LM_DATA, 'LM_VALID', 'lm.valid.txt')
%% df = pd.read_csv(lm_valid, names=['CustomerID','MovieID','Probability'], sep='\t')
%% print(df.shape)
%% df.head()


| CustomerID  |      ModelID      |  Probability |
|-------------|:-----------------:|-------------:|
| col 1 is    |  left-aligned     | $1600        |
| col 2 is    |    centered       |   $12        |
| col 3 is    | right-aligned     |    $1        |


Код:
%% lm_test = os.path.join(LM_DATA, 'LM_VALID', 'lm.valid.txt')
%% df2 = pd.read_csv(lm_valid, names=['CustomerID','MovieID','Probability'], sep='\t')
%% print(df2.shape)
%% df2.head()


| CustomerID  |      ModelID      |  Probability |
|-------------|:-----------------:|-------------:|
| col 1 is    |  left-aligned     | $1600        |
| col 2 is    |    centered       |   $12        |
| col 3 is    | right-aligned     |    $1        |


# Deep Autoencoder для коллаборативной фильтрации

Теперь у нас есть данные, и можно объяснить используемую обучающую модель.
Модель, разработанная NVIDIA, это Deep Autoencoder с 6 слоями с нелинейной функцией 
активации SELU (scaled exponential linear units)

Автоэнкодер это сеть, которая реализует две трансформации: 
$encode(x): {R^n} \to {R^d}
$decoder(z): {R^d} \to {R^n}

Цель автоэнкодера - получить 
The “goal” of autoencoder is to obtain a $d$ dimensional representation of data such that an error measure between $x$ and $f(x) = decode(encode(x))$ is minimized. In the next figure, the autocoder architecture proposed in the paper is showed. Encoder has 2 layers $e_1$ and $e_2$ and decoder has 2 layers $d_1$ and $d_2$. Dropout may be applied to coding layer $z$. In the paper, the authors show experiments with different number of layers, from 2 to 12 (see Table 2 in the original paper).

![]( static/AutoEncoder.png )
